-- 07_create_triggers.sql
-- Скрипт для создания триггеров

BEGIN;

-- 1. Триггер для обновления остатков продуктов при ПОСТУПЛЕНИИ (без изменений)
CREATE OR REPLACE FUNCTION "TG_ОбновитьОстатокПриПоступлении"()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO "ОстатокПродуктаНаСкладе" ("ID_склада", "ID_продукта", "Количество")
    VALUES (
        (SELECT "ID_склада" FROM "Поступление" WHERE "ID_поступления" = NEW."ID_поступления"),
        NEW."ID_продукта",
        NEW."Количество"
    )
    ON CONFLICT ("ID_склада", "ID_продукта") DO UPDATE SET
        "Количество" = "ОстатокПродуктаНаСкладе"."Количество" + EXCLUDED."Количество";
    RAISE NOTICE 'Триггер TG_ОбновитьОстатокПриПоступлении: Остаток продукта ID % на складе ID % обновлен на +%.',
                 NEW."ID_продукта", (SELECT "ID_склада" FROM "Поступление" WHERE "ID_поступления" = NEW."ID_поступления"), NEW."Количество";
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER "trg_after_insert_ПозицияПоступления_update_остаток"
AFTER INSERT ON "ПозицияПоступления"
FOR EACH ROW
EXECUTE FUNCTION "TG_ОбновитьОстатокПриПоступлении"();


-- 2. Триггер для обновления остатков продуктов при СПИСАНИИ ПРОДУКТА (без изменений)
CREATE OR REPLACE FUNCTION "TG_ОбновитьОстатокПриСписанииПродукта"()
RETURNS TRIGGER AS $$
DECLARE
    v_id_склада_списания INTEGER;
BEGIN
    SELECT s."ID_склада" INTO v_id_склада_списания
    FROM "Списание" s WHERE s."ID_списания" = NEW."ID_списания";

    IF v_id_склада_списания IS NULL THEN
        RAISE WARNING 'Триггер TG_ОбновитьОстатокПриСписанииПродукта: Не удалось найти склад для списания ID %.', NEW."ID_списания";
        RETURN NEW;
    END IF;

    UPDATE "ОстатокПродуктаНаСкладе"
    SET "Количество" = "Количество" - NEW."Количество"
    WHERE "ID_склада" = v_id_склада_списания AND "ID_продукта" = NEW."ID_продукта";

    IF NOT FOUND THEN
        RAISE WARNING 'Триггер TG_ОбновитьОстатокПриСписанииПродукта: Продукт ID % не найден на складе ID % для списания или остаток уже 0. Списание произведено.',
                     NEW."ID_продукта", v_id_склада_списания;
        -- Можно добавить логику для создания записи с отрицательным остатком, если это допустимо,
        -- или возбудить исключение, если остаток не может быть отрицательным и проверка на это не сделана ранее.
        -- Для простоты оставляем предупреждение.
    END IF;

    RAISE NOTICE 'Триггер TG_ОбновитьОстатокПриСписанииПродукта: Остаток продукта ID % на складе ID % обновлен на -%.',
                 NEW."ID_продукта", v_id_склада_списания, NEW."Количество";
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER "trg_after_insert_СписаниеПродуктов_update_остаток"
AFTER INSERT ON "СписаниеПродуктов"
FOR EACH ROW
EXECUTE FUNCTION "TG_ОбновитьОстатокПриСписанииПродукта"();


-- 3. НОВЫЙ ТРИГГЕР: Обновление остатков ИНГРЕДИЕНТОВ при СПИСАНИИ БЛЮДА
-- (когда блюдо списывается целиком по причине порчи, проработки и т.д.)
CREATE OR REPLACE FUNCTION "TG_ОбновитьОстатокПриСписанииБлюда"()
RETURNS TRIGGER AS $$
DECLARE
    v_id_склада_списания INTEGER;
    rec_состав RECORD;
BEGIN
    -- Получаем ID_склада из родительской таблицы "Списание"
    SELECT s."ID_склада" INTO v_id_склада_списания
    FROM "Списание" s WHERE s."ID_списания" = NEW."ID_списания"; -- NEW - это строка из "СписаниеБлюд"

    IF v_id_склада_списания IS NULL THEN
        RAISE WARNING 'Триггер TG_ОбновитьОстатокПриСписанииБлюда: Не удалось найти склад для списания ингредиентов блюда (списание ID %).', NEW."ID_списания";
        RETURN NEW;
    END IF;

    -- Перебираем все ингредиенты списываемого блюда
    FOR rec_состав IN
        SELECT "ID_продукта", "Количество" AS "Количество_в_рецепте"
        FROM "СоставБлюда"
        WHERE "ID_блюда" = NEW."ID_блюда" -- NEW."ID_блюда" из таблицы "СписаниеБлюд"
    LOOP
        UPDATE "ОстатокПродуктаНаСкладе"
        SET "Количество" = "Количество" - (rec_состав."Количество_в_рецепте" * NEW."Количество") -- NEW."Количество" - это кол-во списываемых блюд
        WHERE "ID_склада" = v_id_склада_списания AND "ID_продукта" = rec_состав."ID_продукта";

        IF NOT FOUND THEN
            RAISE WARNING 'Триггер TG_ОбновитьОстатокПриСписанииБлюда: Ингредиент ID % не найден на складе ID % для списания или остаток уже 0. Списание произведено.',
                         rec_состав."ID_продукта", v_id_склада_списания;
        END IF;

        RAISE NOTICE 'Триггер TG_ОбновитьОстатокПриСписанииБлюда: Остаток ингредиента ID % на складе ID % обновлен на -% (для списанного блюда ID %).',
                     rec_состав."ID_продукта", v_id_склада_списания, (rec_состав."Количество_в_рецепте" * NEW."Количество"), NEW."ID_блюда";
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER "trg_after_insert_СписаниеБлюд_update_остатки_ингредиентов"
AFTER INSERT ON "СписаниеБлюд"
FOR EACH ROW
EXECUTE FUNCTION "TG_ОбновитьОстатокПриСписанииБлюда"();


-- 4. ДОРАБОТАННЫЙ ТРИГГЕР: Обновление остатков ИНГРЕДИЕНТОВ при ПРОДАЖЕ БЛЮДА
-- (срабатывает при добавлении позиции в заказ)
CREATE OR REPLACE FUNCTION "TG_ОбновитьОстаткиПриПродажеБлюда"()
RETURNS TRIGGER AS $$
DECLARE
    rec_состав RECORD;
    v_id_склада_списания_ингредиентов INTEGER; -- Склад по умолчанию для списания ингредиентов
BEGIN
    -- Определяем склад для списания ингредиентов.
    -- ВАЖНОЕ ДОПУЩЕНИЕ ДЛЯ КУРСОВОЙ: Все ингредиенты для проданных блюд
    -- списываются с основного кухонного склада с ID = 1 (или выберите другой подходящий ID).
    -- В реальной системе эта логика должна быть более гибкой.
    v_id_склада_списания_ингредиентов := 1; -- ЗАМЕНИТЕ НА ID ВАШЕГО ОСНОВНОГО КУХОННОГО СКЛАДА

    RAISE NOTICE 'Триггер TG_ОбновитьОстаткиПриПродажеБлюда: Попытка списания ингредиентов для блюда ID % со склада ID %.',
                 NEW."ID_блюда", v_id_склада_списания_ингредиентов;

    FOR rec_состав IN
        SELECT "ID_продукта", "Количество" AS "Количество_в_рецепте"
        FROM "СоставБлюда"
        WHERE "ID_блюда" = NEW."ID_блюда" -- NEW - это строка из "ПозицияЗаказа"
    LOOP
        UPDATE "ОстатокПродуктаНаСкладе"
        SET "Количество" = "Количество" - (rec_состав."Количество_в_рецепте" * NEW."Количество") -- NEW."Количество" - это кол-во проданных блюд
        WHERE "ID_склада" = v_id_склада_списания_ингредиентов AND "ID_продукта" = rec_состав."ID_продукта";

        IF NOT FOUND THEN
            RAISE WARNING 'Триггер TG_ОбновитьОстаткиПриПродажеБлюда: Ингредиент ID % не найден на складе ID % для списания при продаже или остаток уже 0. Списание произведено.',
                         rec_состав."ID_продукта", v_id_склада_списания_ингредиентов;
            -- ВАЖНО: Здесь должна быть логика обработки ситуации, когда ингредиента нет на складе!
            -- Например, запрет добавления в заказ, откат транзакции или специальное уведомление.
            -- Для курсовой можно оставить предупреждение, но в описании указать на это ограничение.
        END IF;

        RAISE NOTICE 'Триггер TG_ОбновитьОстаткиПриПродажеБлюда: Остаток ингредиента ID % на складе ID % обновлен на -% (для проданного блюда ID % в заказе ID %).',
                     rec_состав."ID_продукта", v_id_склада_списания_ингредиентов,
                     (rec_состав."Количество_в_рецепте" * NEW."Количество"), NEW."ID_блюда", NEW."ID_заказа";
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Заменяем старый триггер или создаем новый, если его не было
CREATE OR REPLACE TRIGGER "trg_after_insert_ПозицияЗаказа_update_остатки_ингредиентов"
AFTER INSERT ON "ПозицияЗаказа"
FOR EACH ROW
EXECUTE FUNCTION "TG_ОбновитьОстаткиПриПродажеБлюда"();

COMMIT;